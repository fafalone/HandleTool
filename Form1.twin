[Description("HandleTool v1.2")]
[FormDesignerId("C4BC32F0-FD71-4E3E-951C-15F6230C70AE")]
[PredeclaredId]
Class Form1
    Option Explicit
    '**********************************************************
    'HandleTool v2.0.5
    'by Jon Johnson
    '
    'A small utility to list various files/handles in use by a
    'selected process, or to search for which process is using
    'a specific file.
    '
    'Project repository:
    ' https://github.com/fafalone/HandleTool
    '
    'Version 2.0.5 (05 Dec 2025)
    '- Handles now in sorted ListView with multiple columns
    '- Option to close handle via right-click menu
    '- Option to kill process via right-click menu
    '- Additional categories for explicit handle types
    '- Token handles now look up domain\user as name
    '
    'Version 1.2.4 (04 Dec 2025)
    '- Enable SE_DEBUG_PRIVILEGE to be able to list/search for
    '  handles in SYSTEM processes.
    '- Fix NtPath->DosPath error in some cases from not mapping
    '  volumes on startup.
    'Version 1.1.2 (04 Dec 2025)
    '- Double click to list handles
    '- In some cases, NtQueryObject for the name would hang, so
    '  the name lookup is now done on a separate thread with a 
    '  250ms timeout.
    '- ListView should be single sel
    '- Section handle display broken
    '- Fixed some handle leaks
    '
    '03 Dec 2025 - Initial release
    '
    '**********************************************************
      
    Private dbgsc As Long
    Private himlSys16 As LongPtr
    Private himlSys32 As LongPtr
    
    Private hLV As LongPtr
    Private hLVCHdr As LongPtr
    Private hLVH As LongPtr
    Private hLVHHdr As LongPtr
       
    Private Type PLProcess
        pid As Long
        sDisplayName As String
        sFullPath As String
        sCommandLine As String
        nIconIndex As Long
    End Type
    Private PLProcesses() As PLProcess
    Private nProc As Long
    Private Const sCol0 As String = "Process"
    Private Const sCol1 As String = "PID"
    
    Private pidCur As Long 'Currently listed process id
    
    Private Type HandleInfo
        sType As String
        sName As String
        sAlt As String
        dwAccess As Long
        HandleId As LongPtr
    End Type
    Private curHandles() As HandleInfo
    Private nCurH As Long
    Private Const sColH0 As String = "Type"
    Private Const sColH1 As String = "Name"
    Private Const sColH2 As String = "Access"
    Private Const sColH3 As String = "Handle"
    
    Private Const sMnu1 As String = "Close handle"
    Private Const sMnu2 As String = "Copy name"
    
    Private Const sPMnu1 As String = "Kill process"
       
    
    Private Type NAME_QUERY_DATA
        hTarget As LongPtr
        pBuffer As LongPtr
        cbBuffer As Long
        status As NTSTATUS
    End Type

    Private nSortKey As Long
    Private nHSortKey As Long
    Private Enum LVSortDir
        sortAscending
        sortDescending
    End Enum
    Private nSortDir As LVSortDir
    Private nHSortDir As LVSortDir
    
    Private Type VolData
        sLetter As String
        sName As String
    End Type
    Private VolMap() As VolData
    Private bSetVM As Boolean
    
    Public Sub PostLog(ByVal sMsg As String)
    sMsg = "[" & Format$(Now, "Hh:nn:Ss") & "] " & sMsg & vbCrLf
    Debug.Print sMsg
    End Sub
    
    Private Sub Command1_Click() Handles Command1.Click
        Dim sPid As String
        Dim lp As LongPtr
        Dim li As Long = CLng(ListView_GetSelectedItem(hLV))
        If li >= 0 Then
            Text1.Text = ""
            lp = GetLVItemlParam(hLV, li)
            ListHandlesForProc(PLProcesses(CLng(lp)).pid)
        End If
    End Sub
 
    Private Sub Label2_MouseMove(Button As Integer, Shift As Integer, X As Single, Y As Single) Handles Label2.MouseMove
    If Button = 1 Then
        Call ReleaseCapture
        Call SendMessage(pbFind.hWnd, WM_NCLBUTTONDOWN, HTCAPTION, 0&)
    End If
    End Sub
    
    Private Sub pbFind_MouseMove(Button As Integer, Shift As Integer, X As Single, Y As Single) Handles pbFind.MouseMove
    If Button = 1 Then
        Call ReleaseCapture
        Call SendMessage(pbFind.hWnd, WM_NCLBUTTONDOWN, HTCAPTION, 0&)
    End If
    End Sub
    Private Sub Frame1_MouseMove(Button As Integer, Shift As Integer, X As Single, Y As Single) Handles Frame1.MouseMove
    If Button = 1 Then
        Call ReleaseCapture
        Call SendMessage(pbFind.hWnd, WM_NCLBUTTONDOWN, HTCAPTION, 0&)
    End If
    End Sub
    Private Sub Command2_Click() Handles Command2.Click
    If pbFind.Visible = False Then
        Text2.Text = ""
        SetParent pbFind.hWnd, Me.hWnd
        pbFind.Visible = True
        pbFind.Top = pbLVH.Top + 200
        pbFind.Left = pbLVH.Left + 200
        Dim dwFrEx As Long
        dwFrEx = CLng(GetWindowLong(pbFind.hWnd, GWL_EXSTYLE))
        dwFrEx = dwFrEx Or WS_EX_DLGMODALFRAME
        SetWindowLong pbFind.hWnd, GWL_EXSTYLE, dwFrEx
    
        SetWindowPos pbFind.hWnd, 0&, 0&, 0&, 0&, 0&, SWP_NOSIZE Or SWP_NOMOVE Or SWP_NOZORDER Or SWP_NOACTIVATE Or SWP_FRAMECHANGED
    End If
    End Sub
    
    Private Sub Command3_Click() Handles Command3.Click
        Text1.Text = ""
        If PathFileExists(Text2.Text) Then
            pbFind.Visible = False
             FindProcsUsingFile(Text2.Text)
        Else
            Text1.Text = "Invalid file specified for search."
        End If
    End Sub
    
    Private Sub Command4_Click() Handles Command4.Click
        pbFind.Visible = False
    End Sub
    
    Private Sub Command5_Click() Handles Command5.Click
        Dim pFOD As FileOpenDialog
        Dim pFile As IShellItem
    
        Set pFOD = New FileOpenDialog
        With pFOD
            .SetTitle "Pick file..."
            .SetOptions FOS_FORCEFILESYSTEM Or FOS_PATHMUSTEXIST
            On Error Resume Next
            .Show Me.hWnd
            .GetResult pFile
            On Error GoTo 0
            If (pFile Is Nothing) = False Then
                Dim lpPath As LongPtr
                pFile.GetDisplayName SIGDN_FILESYSPATH, lpPath
                Text2.Text = LPWSTRtoStr(lpPath)
            End If
        End With
    End Sub
    
    Private Sub Command6_Click() Handles Command6.Click
        RefreshProcessList()
    End Sub
    
    Private Sub pbLV_Resize() Handles pbLV.Resize
        If hLV Then
            SetWindowPos hLV, 0, 0, 0, pbLV.ScaleWidth, pbLV.ScaleHeight, SWP_NOMOVE Or SWP_NOZORDER
        End If
    End Sub
    Private Sub pbLVH_Resize() Handles pbLVH.Resize
        If hLVH Then
            SetWindowPos hLVH, 0, 0, 0, pbLVH.ScaleWidth, pbLVH.ScaleHeight, SWP_NOMOVE Or SWP_NOZORDER
        End If
    End Sub
    
    Private Sub InitListView()
        
 
        Dim dwFlags As Long = WS_CHILD Or WS_VISIBLE Or WS_CLIPSIBLINGS Or WS_CLIPCHILDREN Or _
                                LVS_REPORT Or LVS_SHOWSELALWAYS Or LVS_AUTOARRANGE Or LVS_ALIGNTOP Or LVS_SINGLESEL
        Dim dwFlagsEx As Long = WS_EX_CLIENTEDGE
        
        hLV = CreateWindowEx(dwFlagsEx, WC_LISTVIEW, vbNullString, dwFlags, 0, 0, pbLV.ScaleWidth, pbLV.ScaleHeight, _
          pbLV.hWnd, 0, App.hInstance, ByVal 0)
 
        ListView_SetExtendedStyle(hLV, LVS_EX_JUSTIFYCOLUMNS Or LVS_EX_DOUBLEBUFFER Or LVS_EX_FULLROWSELECT Or LVS_EX_LABELTIP Or LVS_EX_HEADERDRAGDROP)
        SetWindowTheme(hLV, "explorer", vbNullString)
        Shell_GetImageLists himlSys32, himlSys16
        ListView_SetImageList hLV, himlSys16, LVSIL_SMALL
        ListView_SetImageList hLV, himlSys32, LVSIL_NORMAL
    
        hLVCHdr = SendMessage(hLV, LVM_GETHEADER, 0, ByVal 0) ' ListView_GetHeader(hLV)
          
        InsertColumns()
 
        Subclass2 pbLV.hWnd, AddressOf LVWndProc, pbLV.hWnd
    End Sub
    Private Sub InitHandleListView()
        
 
        Dim dwFlags As Long = WS_CHILD Or WS_VISIBLE Or WS_CLIPSIBLINGS Or WS_CLIPCHILDREN Or _
                                LVS_REPORT Or LVS_SHOWSELALWAYS Or LVS_AUTOARRANGE Or LVS_ALIGNTOP Or LVS_SINGLESEL
        Dim dwFlagsEx As Long = WS_EX_CLIENTEDGE
        
        hLVH = CreateWindowEx(dwFlagsEx, WC_LISTVIEW, vbNullString, dwFlags, 0, 0, pbLVH.ScaleWidth, pbLVH.ScaleHeight, _
          pbLVH.hWnd, 0, App.hInstance, ByVal 0)
 
        ListView_SetExtendedStyle(hLVH, LVS_EX_JUSTIFYCOLUMNS Or LVS_EX_DOUBLEBUFFER Or LVS_EX_FULLROWSELECT Or LVS_EX_LABELTIP Or LVS_EX_HEADERDRAGDROP)
        SetWindowTheme(hLVH, "explorer", vbNullString)
 
    
        hLVHHdr = SendMessage(hLVH, LVM_GETHEADER, 0, ByVal 0) ' ListView_GetHeader(hLV)
          
        InsertHandleColumns()
 
        Subclass2 pbLVH.hWnd, AddressOf LVHWndProc, pbLVH.hWnd
    End Sub
    
    Private Sub InsertColumns()
        Dim lvc As LVCOLUMN
        Dim HDI As HDITEMW
        lvc.Mask = LVCF_TEXT Or LVCF_WIDTH
        lvc.pszText = StrPtr(sCol0)
        lvc.cchTextMax = Len(sCol0)
        lvc.CX = 180
        SendMessage(hLV, LVM_INSERTCOLUMN, 0, lvc)
        HDI.Mask = HDI_LPARAM
        HDI.lParam = 1&
        Call SendMessage(hLVCHdr, HDM_SETITEMW, 0&, HDI)
        lvc.Mask = LVCF_TEXT Or LVCF_WIDTH
        lvc.pszText = StrPtr(sCol1)
        lvc.cchTextMax = Len(sCol1)
        lvc.CX = 50
        SendMessage(hLV, LVM_INSERTCOLUMN, 1, lvc)
        HDI.Mask = HDI_LPARAM
        HDI.lParam = 2&
        Call SendMessage(hLVCHdr, HDM_SETITEMW, 1&, HDI)
        
        Debug.Print GetHDItemlParam(hLVCHdr, 1)
   End Sub
                 
    Private Sub InsertHandleColumns()
        Dim lvc As LVCOLUMN
        Dim HDI As HDITEMW
        lvc.Mask = LVCF_TEXT Or LVCF_WIDTH
        lvc.pszText = StrPtr(sColH0)
        lvc.cchTextMax = Len(sColH0)
        lvc.CX = 70
        SendMessage(hLVH, LVM_INSERTCOLUMN, 0, lvc)
        HDI.Mask = HDI_LPARAM
        HDI.lParam = 1&
        Call SendMessage(hLVHHdr, HDM_SETITEMW, 0&, HDI)
        lvc.Mask = LVCF_TEXT Or LVCF_WIDTH
        lvc.pszText = StrPtr(sColH1)
        lvc.cchTextMax = Len(sColH1)
        lvc.CX = 180
        SendMessage(hLVH, LVM_INSERTCOLUMN, 1, lvc)
        HDI.Mask = HDI_LPARAM
        HDI.lParam = 2&
        Call SendMessage(hLVHHdr, HDM_SETITEMW, 1&, HDI)
        lvc.Mask = LVCF_TEXT Or LVCF_WIDTH
        lvc.pszText = StrPtr(sColH2)
        lvc.cchTextMax = Len(sColH2)
        lvc.CX = 80
        SendMessage(hLVH, LVM_INSERTCOLUMN, 2, lvc)
        HDI.Mask = HDI_LPARAM
        HDI.lParam = 3&
        Call SendMessage(hLVHHdr, HDM_SETITEMW, 2&, HDI)
        lvc.Mask = LVCF_TEXT Or LVCF_WIDTH
        lvc.pszText = StrPtr(sColH3)
        lvc.cchTextMax = Len(sColH3)
        lvc.CX = 50
        SendMessage(hLVH, LVM_INSERTCOLUMN, 3, lvc)
        HDI.Mask = HDI_LPARAM
        HDI.lParam = 4&
        Call SendMessage(hLVHHdr, HDM_SETITEMW, 3&, HDI)
               
                
    End Sub
    
    Private Function LVInsertItem(ByVal hWnd As LongPtr, ByVal nMask As LVITEM_mask, ByVal nItem As Long, ByVal lpszItem As String, ByVal nState As LVITEM_state, ByVal nStateMask As LVITEM_state, ByVal nImage As Long, ByVal lParam As LongPtr) As Long
        Dim item As LVITEM
        item.Mask = nMask
        item.iItem = nItem
        item.iSubItem = 0
        item.pszText = StrPtr(lpszItem)
        item.State = nState
        item.StateMask = nStateMask
        item.iImage = nImage
        item.lParam = lParam
        Return CLng(SendMessage(hWnd, LVM_INSERTITEM, 0, item))
    End Function
    Private Function LVSetItem(ByVal hWnd As LongPtr, ByVal nItem As Long, ByVal nSubItem As Long, ByVal nMask As LVITEM_mask, ByVal lpszItem As LongPtr, _
                        ByVal nImage As Long, ByVal nState As LVITEM_state, ByVal nStateMask As LVITEM_state, ByVal lParam As LongPtr) As BOOL
        
        Dim lvi As LVITEM
        lvi.Mask = nMask
        lvi.iItem = nItem
        lvi.iSubItem = nSubItem
        lvi.StateMask = nStateMask
        lvi.State = nState
        lvi.pszText = lpszItem
        lvi.iImage = nImage
        lvi.lParam = lParam
        Return CLng(SendMessage(hWnd, LVM_SETITEM, 0, lvi))
        
    End Function
    Private Function LVSetItemText(ByVal hWnd As LongPtr, ByVal nItem As Long, ByVal nSubItem As Long, ByVal lpszText As String) As BOOL
        Return LVSetItem(hWnd, nItem, nSubItem, LVIF_TEXT, StrPtr(lpszText), 0, 0, 0, 0)
    End Function
    Private Function LVSetItemText(ByVal hWnd As LongPtr, ByVal nItem As Long, ByVal nSubItem As Long, ByVal lpszText As LongPtr) As BOOL
        Return LVSetItem(hWnd, nItem, nSubItem, LVIF_TEXT, lpszText, 0, 0, 0, 0)
    End Function
    
    Private Sub RefreshProcessList()
        ReDim PLProcesses(0)
        Dim tProc As PROCESSENTRY32W
        Dim hSnap As LongPtr
        Dim hr As Long
        
        nProc = 0
        
        hSnap = CreateToolhelp32Snapshot(TH32CS_SNAPPROCESS, 0)
        
        If hSnap <> INVALID_HANDLE_VALUE Then
            tProc.dwSize = LenB(Of PROCESSENTRY32W)
            hr = Process32FirstW(hSnap, tProc)
            If hr > 0& Then
                Do While hr > 0&
                    ReDim Preserve PLProcesses(nProc)
                    PLProcesses(nProc).pid = tProc.th32ProcessID
                    If (tProc.th32ProcessID = 0) Then
                        PLProcesses(nProc).sDisplayName = "[System idle process]"
                        PLProcesses(nProc).nIconIndex = 2
                    ElseIf (tProc.th32ProcessID = 4) Then
                        PLProcesses(nProc).sDisplayName = "System"
                        PLProcesses(nProc).nIconIndex = 2
                    Else
                        PLProcesses(nProc).sDisplayName = WCHARtoSTR(tProc.szExeFile)
                        'Debug.Print "AddProc(" & PLProcesses(nProc).pid & ")=" & PLProcesses(nProc).sDisplayName
                        PLProcesses(nProc).sCommandLine = GetProcessCommandLine(tProc.th32ProcessID, PLProcesses(nProc).sDisplayName)
                        hr = GetProcessFullPath(PLProcesses(nProc).pid, PLProcesses(nProc).sFullPath)
                        PLProcesses(nProc).nIconIndex = GetFileIconIndex(PLProcesses(nProc).sFullPath, SHGFI_SMALLICON)
                        If PLProcesses(nProc).nIconIndex = 0 Then PLProcesses(nProc).nIconIndex = 2
                    End If

                    nProc += 1
                    hr = Process32NextW(hSnap, tProc)
                Loop
            Else
                PostLog "Error calling Process32First, 0x" & Hex$(Err.LastDllError) & ", hSnapshot=" & hSnap
            End If
            CloseHandle hSnap
        Else
            PostLog "Error creating process snapshot."
        End If
        
        ListView_DeleteAllItems(hLV)
        If nProc Then
            Dim i As Long
 
            For i = 0 To UBound(PLProcesses)
                LVInsertItem(hLV, LVIF_IMAGE Or LVIF_TEXT Or LVIF_PARAM, i, PLProcesses(i).sDisplayName, 0, 0, PLProcesses(i).nIconIndex, i)
                LVSetItemText(hLV, i, 1, StrPtr(CStr(PLProcesses(i).pid)))
            Next
        End If
    End Sub

    Private Function SetLVItemIcon(hwndLV As LongPtr, iItem As Long, ByVal nIcon As Long) As Boolean
      Dim lvi As LVITEMW
  
      lvi.Mask = LVIF_IMAGE
      lvi.iItem = iItem
      lvi.iImage = nIcon
      Return (SendMessage(hwndLV, LVM_SETITEM, 0, lvi) <> 0)

    End Function
    Private Function GetLVItemTextW(hWnd As LongPtr, iItem As Long, iSub As Long) As String
    Dim flvi As LVITEM
    With flvi
        Dim Buffer As String
        Buffer = String$(MAX_PATH, vbNullChar)
        .pszText = StrPtr(Buffer)
        .cchTextMax = MAX_PATH
        .iSubItem = iSub
    End With
    SendMessage hWnd, LVM_GETITEMTEXTW, iItem, ByVal VarPtr(flvi)
    If InStr(Buffer, vbNullChar) > 1 Then
        GetLVItemTextW = Left$(Buffer, InStr(Buffer, vbNullChar) - 1) ', vbUnicode)
    End If
    End Function
    Public Function GetFileIconIndex(Path As String, uType As Long) As Long
      Dim sfi As SHFILEINFO
      If SHGetFileInfo(ByVal Path, ByVal 0&, sfi, LenB(sfi), SHGFI_SYSICONINDEX Or SHGFI_SMALLICON Or SHGFI_TYPENAME) Then
        Return sfi.iIcon
      End If
      
    End Function
    
    Public Function GetProcessCommandLine(pid As Long, sProc As String) As String
    GetProcessCommandLine = " "
    If (pid <= 0&) Or (pid = 4&) Then Exit Function 'Invalid, system idle, and system process. Command line n/a.
    Dim tPEB As PEB
    Dim tUPP As RTL_USER_PROCESS_PARAMETERS
    Dim tPBI As PROCESS_BASIC_INFORMATION
    Dim hProc As LongPtr
    Dim status As Long
    Dim dwSizeNeeded As Long
    Dim cbRead As LongPtr
    Dim sOut As String

    hProc = OpenProcess(PROCESS_QUERY_INFORMATION Or PROCESS_VM_READ, 0&, pid)
    If hProc > 0 Then
        status = NtQueryInformationProcess(hProc, ProcessBasicInformation, tPBI, LenB(tPBI), dwSizeNeeded)
        If tPBI.PebBaseAddress Then
            If ReadProcessMemory(hProc, tPBI.PebBaseAddress, tPEB, LenB(tPEB), cbRead) Then
                cbRead = 0&
                If ReadProcessMemory(hProc, tPEB.ProcessParameters, tUPP, LenB(tUPP), cbRead) Then
                    If tUPP.CommandLine.Length Then
                        cbRead = 0&
                        Dim bstr() As Byte
                        ReDim bstr(tUPP.CommandLine.Length - 1)
                        If ReadProcessMemory(hProc, tUPP.CommandLine.Buffer, bstr(0), tUPP.CommandLine.Length, cbRead) Then
                            sOut = bstr
                            'PostLog "read=" & cbRead & ",sOut=" & sOut
                            Return sOut
                        End If
                    Else
                        PostLog "CmdLineLen=0 for " & sProc
                    End If
                Else
                    PostLog "Failed to read process params for " & sProc
                End If
            Else
                PostLog "Failed to read PEB for " & sProc
            End If
        Else
            PostLog "Failed to obtain PebBaseAddress for " & hProc & ", status=0x" & Hex(status)
        End If
        CloseHandle hProc
    Else
        'PostLog "Failed to open process " & sProc & ", err=0x" & Hex$(Err.LastDllError)
    End If

    End Function
    Private Function GetProcessFullPath(pid As Long, pPath As String) As Long
    On Error GoTo GetProcessFullPath_Err
    Dim hProc As LongPtr
    Dim sBuf As String
    Dim cb As Long
    Dim lErr As Long
    hProc = OpenProcess(PROCESS_QUERY_LIMITED_INFORMATION, 0&, pid)
    lErr = Err.LastDllError
    If hProc Then
        sBuf = String$(MAX_PATH, 0)
        Dim hr As Long
        cb = MAX_PATH
        hr = QueryFullProcessImageName(hProc, 0&, sBuf, cb)
        lErr = Err.LastDllError
        If hr Then
            pPath = Left$(sBuf, cb)
        Else
            Debug.Print "Error with QueryFullProcessImageName for pid=" & pid & ",err=0x" & Hex$(lErr)
            GetProcessFullPath = lErr
        End If
    Else
        If lErr = ERROR_ACCESS_DENIED Then
            'Only use undocumented APIs if needed
            Return GetProcessFullPathEx(pid, pPath)
        End If
        Debug.Print "Couldn't obtain GetProcessFullPath for pid=" & pid & ",err=0x" & Hex$(lErr)
        GetProcessFullPath = lErr
    End If

    Exit Function

    GetProcessFullPath_Err:
        PostLog "GetProcessFullPath.Error->" & Err.Description & ", 0x" & Hex$(Err.Number)
    End Function
    
    Private Function GetProcessFullPathEx(pid As Long, pPath As String) As Long
        'Regular method can't get path of SYSTEM process
        'Note: API Returns NT path
        Dim status As NTSTATUS
        Dim lpBuffer As LongPtr
        Dim spii As SYSTEM_PROCESS_ID_INFORMATION
        Dim sTemp As String
        Dim cbMax As Long = MAX_PATH * LenB(Of Integer) ' * sizeof(WCHAR)
        Dim cbRet As Long
        lpBuffer = LocalAlloc(LMEM_FIXED, cbMax)
        spii.ProcessId = pid
        spii.ImageName.MaximumLength = cbMax
        spii.ImageName.Buffer = lpBuffer
        
        status = NtQuerySystemInformation(SystemProcessIdInformation, spii, LenB(Of SYSTEM_PROCESS_ID_INFORMATION), cbRet)
        If NT_SUCCESS(status) Then
            sTemp = LPWSTRtoStr(lpBuffer, False)
            'Debug.Print "NtQuerySystemInformation(SystemProcessIdInformation) reported success; cbRet=" & cbRet & ",status=" & status & ",lpBuffer=0x" & Hex$(lpBuffer) & ",spii buffer=0x" & Hex$(spii.ImageName.pBuffer) & ", pPath=" & pPath
            If bSetVM = False Then
                MapVolumes
            End If
            pPath = ConvertNtPathToDosPath(sTemp)
        Else
            Debug.Print "GetProcessFullPathEx error, 0x" & Hex$(status)
        End If
        
        LocalFree lpBuffer
        Return status
    End Function
    Private Sub MapVolumes()
    'Map out \Device\Harddiskblahblah
    Dim sDrive As String
    Dim i As Long, j As Long
    Dim sBuffer As String
    ReDim VolMap(0)
    Dim tmpMap() As VolData
    Dim nMap As Long, nfMap As Long
    Dim lIdx As Long
    Dim lnMax As Long
    Dim cb As Long
    For lIdx = 0 To 25
        sDrive = Chr$(65 + lIdx) & ":"
        sBuffer = String$(1000, vbNullChar)
        cb = QueryDosDevice(sDrive, sBuffer, Len(sBuffer))
        If cb Then
            ReDim Preserve tmpMap(nMap)
            tmpMap(nMap).sLetter = sDrive
            tmpMap(nMap).sName = TrimNullW(sBuffer)
            nMap = nMap + 1
        End If
    Next
    'Next we need to sort the array so e.g. 10 will always come before 1
    'We'll find the longest ones, add any of that length, then add any
    'of 1 char shorter, until we've added all items
    For i = 0 To (nMap - 1)
        If Len(tmpMap(i).sName) > lnMax Then lnMax = Len(tmpMap(i).sName)
    Next i
    ReDim VolMap(nMap - 1)
    For i = lnMax To 1 Step -1
        For j = 0 To UBound(tmpMap)
            If Len(tmpMap(j).sName) = i Then
                VolMap(nfMap).sName = tmpMap(j).sName
                VolMap(nfMap).sLetter = tmpMap(j).sLetter
                nfMap = nfMap + 1
            End If
        Next j
        If nfMap = nMap Then Exit For
    Next i
    bSetVM = True
    End Sub

    'Then we can convert path names by running through the ones we got and replacing any
    'occurences of them. The array is presorted so 10 comes before 1.
    Private Function ConvertNtPathToDosPath(sPath As String) As String
    If sPath = "" Then Exit Function
 
    Dim i As Long
    ConvertNtPathToDosPath = sPath
    For i = 0 To UBound(VolMap)
        ConvertNtPathToDosPath = Replace$(ConvertNtPathToDosPath, VolMap(i).sName, VolMap(i).sLetter, 1, 1)
    Next
    End Function
    Private Function TrimNullW(startstr As String) As String
    Dim cch As Long = lstrlenW(ByVal StrPtr(startstr))
    If cch = 0 Then Return ""
    TrimNullW = Left$(startstr, cch)
    End Function
    
   
    Private Sub Form_Load() Handles Form.Load
        nSortDir = -1
        nHSortDir = -1
        pidCur = -1
        Dim hToken          As LongPtr
        Dim dwIsElevated    As Long
        Dim dwLength        As Long
    
        If OpenProcessToken(GetCurrentProcess, TOKEN_QUERY, hToken) Then
            If GetTokenInformation(hToken, TokenElevation, dwIsElevated, 4, dwLength) Then
                If dwIsElevated Then
                    Dim enabled As Byte
                    Dim status As NTSTATUS = RtlAdjustPrivilege(SE_DEBUG_PRIVILEGE, 1, 0, enabled)
                    If NT_SUCCESS(status) Then
                        Debug.Print "Successfully enabled debug privilege."
                    Else
                        Debug.Print "Failed to enable debug privilege. You must run this program as Administrator"
                    End If
                Else
                    Text1.Text = "It's recommended you run this program as Administrator or SYSTEM."
                End If
            End If
            Call CloseHandle(hToken)
        End If
        
        MapVolumes()

        InitListView()
        InitHandleListView()
        
        RefreshProcessList
        
        SendMessage(hLV, LVM_SETVIEW, LV_VIEW_DETAILS, ByVal 0&)
        
        SHAutoComplete(Text2.hWnd, SHACF_FILESYS_ONLY)
    End Sub
    
    Private Function CloseRemoteHandle(ByVal pid As Long, ByVal h As LongPtr) As Long
        Dim hProc As LongPtr = OpenProcess(PROCESS_DUP_HANDLE, CFALSE, pid)
        If hProc = 0 Then
            Text1.Text = "Couldn't open process; 0x" & Hex$(Err.LastDllError) & ", " & GetSystemErrorString(Err.LastDllError)
            Return Err.LastDllError
        End If
        If DuplicateHandle(hProc, h, 0, ByVal 0, 0, CFALSE, DUPLICATE_CLOSE_SOURCE) Then
            Return S_OK
        Else
            Return Err.LastDllError
        End If
    End Function
    Private Function KillProcess(ByVal pid As Long) As NTSTATUS
        Dim hProc As LongPtr
        Dim oa As OBJECT_ATTRIBUTES
        oa.Length = LenB(oa)
        Dim cid As CLIENT_ID
        cid.UniqueProcess = pid
        Dim status As NTSTATUS = NtOpenProcess(hProc, PROCESS_TERMINATE, oa, cid)
        If NT_SUCCESS(status) And (hProc <> 0) Then
            status = NtTerminateProcess(hProc, 1)
        End If
        NtClose(hProc)
    End Function
    
    Private Sub AppendText(ByVal sMsg As String)
        Text1.Text &= sMsg & vbCrLf
        SendMessage Text1.hWnd, EM_SCROLL, SB_BOTTOM, ByVal 0&
    End Sub
    Public Function DisplayHandle(ByVal sType As String, ByVal sName As String) As Boolean
    If (Check1.Value = vbChecked) AndAlso (sType = "File") Then
        AppendText "File: " & ConvertNtPathToDosPath(sName)
    ElseIf (Check3.Value = vbChecked) AndAlso (sType = "Directory") Then
        AppendText "Directory: " & ConvertNtPathToDosPath(sName)
    ElseIf (Check4.Value = vbChecked) AndAlso (sType = "Key") Then
        AppendText "Key: " & sName
    ElseIf (Check2.Value = vbChecked) AndAlso (sType = "Section") Then
        AppendText "Section: " & sName
    ElseIf (Check6.Value = vbChecked) AndAlso (sType = "Desktop") Then
        AppendText "Desktop: " & sName
    ElseIf (Check7.Value = vbChecked) AndAlso (sType = "WindowStation") Then
        AppendText "WindowStation: " & sName
    ElseIf Check5.Value = vbChecked Then
        AppendText sType & ": " & sName
    End If
    
    End Function
    
    Private Sub AddDisplayHandle(ByVal idx As Long)
        Dim i As Long = LVInsertItem(hLVH, LVIF_TEXT Or LVIF_PARAM, CLng(ListView_GetItemCount(hLVH)) + 1, curHandles(idx).sType, 0, 0, 0, idx)
        LVSetItemText(hLVH, i, 1, StrPtr(curHandles(idx).sName))
        LVSetItemText(hLVH, i, 2, StrPtr("0x" & Hex$(curHandles(idx).dwAccess)))
        LVSetItemText(hLVH, i, 3, StrPtr("0x" & Hex$(CLng(curHandles(idx).HandleId))))
                  
    End Sub
 
    Private Function NeedHandleName(ByVal sType As String) As Boolean
        If Check5.Value = vbChecked Then Return True
        If (sType = "File") AndAlso (Check1.Value = vbChecked) Then Return True
        If (sType = "Directory") AndAlso (Check3.Value = vbChecked) Then Return True
        If (sType = "Key") AndAlso (Check4.Value = vbChecked) Then Return True
        If (sType = "Section") AndAlso (Check2.Value = vbChecked) Then Return True
        If (sType = "Desktop") AndAlso (Check6.Value = vbChecked) Then Return True
        If (sType = "WindowStation") AndAlso (Check7.Value = vbChecked) Then Return True
        
        Return False
    End Function
    
    [ArrayBoundsChecks(False)]
    Private Function ListHandlesForProc(ByVal pid As Long) As Long
        Dim hProc As LongPtr = OpenProcess(PROCESS_QUERY_INFORMATION Or PROCESS_DUP_HANDLE, CFALSE, pid)
        If hProc = 0 Then
            pidCur = -1
            Text1.Text = "Couldn't open process; 0x" & Hex$(Err.LastDllError) & ", " & GetSystemErrorString(Err.LastDllError)
            Return Err.LastDllError
        End If
        pidCur = pid
        ReDim curHandles(0)
        nCurH = 0
        ListView_DeleteAllItems(hLVH)
        Dim buf() As Byte
        ReDim buf(1023)
        Dim size As Long = 1024
        
        Do
            Dim status As NTSTATUS = NtQueryInformationProcess(hProc, ProcessHandleInformation, buf(0), size, size)
            If NT_SUCCESS(status) Then
                Exit Do
            ElseIf status = STATUS_INFO_LENGTH_MISMATCH Then
                size += 1024
                ReDim buf(size - 1)
                Continue Do
            End If
            Text1.Text = "Error enumerating handles; 0x" & Hex$(Err.LastDllError) & ", " & GetSystemErrorString(Err.LastDllError)
            Return Err.LastDllError
        Loop
        Dim status2 As NTSTATUS
        Dim h As LongPtr
        Dim hTarget As LongPtr
        Dim sName As String
        Dim sType As String
        Dim nameBuffer() As Byte
        Dim typeBuffer() As Byte
        
        With CType(Of PROCESS_HANDLE_SNAPSHOT_INFORMATION)(VarPtr(buf(0)))
            If .NumberOfHandles > 0 Then
                ReDim curHandles(CLng(.NumberOfHandles) - 1)
                For i As LongPtr = 0 To .NumberOfHandles - 1
                    h = .Handles(i).HandleValue
                    If DuplicateHandle(hProc, h, GetCurrentProcess(), hTarget, 0, CFALSE, DUPLICATE_SAME_ACCESS) = 0 Then
                        Continue For
                    End If
                    ReDim nameBuffer(2047)
                    ReDim typeBuffer(1023)
                    status2 = NtQueryObject(hTarget, ObjectTypeInformation, typeBuffer(0), UBound(typeBuffer) + 1, ByVal 0)
                    sType = LPWSTRtoStr(CType(Of OBJECT_TYPE_INFORMATION)(VarPtr(typeBuffer(0))).TypeName.Buffer, False)
 
                    If NeedHandleName(sType) Then
                        Dim nd As NAME_QUERY_DATA
                        Dim hThread As LongPtr
                        Dim tid As Long

                        nd.hTarget = hTarget
                        nd.pBuffer = VarPtr(nameBuffer(0))
                        nd.cbBuffer = UBound(nameBuffer) + 1

                        'Some NtQueryObject calls hang, so look up the name in a separate thread and time it out if too long
                        'GetFinalPathNameByHandle will hang as well in this situation.
                        hThread = CreateThread(ByVal 0, 0, AddressOf NameQueryThreadProc, ByVal VarPtr(nd), 0, tid)
    
                        If WaitForSingleObject(hThread, 250) = WAIT_TIMEOUT Then ' 
                            TerminateThread hThread, 1
                            sName = "(unavailable)"
                        Else
                            If NT_SUCCESS(nd.status) Then  ' 
                                sName = LPWSTRtoStr(CType(Of OBJECT_NAME_INFORMATION)(VarPtr(nameBuffer(0))).Name.Buffer, False)
                                ' If sName = "" Then
                                '     status = NtQueryObject(hTarget, ObjectNameInformation, nameBuffer(0), UBound(nameBuffer) + 1, ByVal 0)
                                '     sName = LPWSTRtoStr(CType(Of OBJECT_NAME_INFORMATION)(VarPtr(nameBuffer(0))).Name.Buffer, False)
                                '     Debug.Print "non-threaded re-query sname=" & sName
                                ' End If
                            Else
                                sName = "(status=0x" & Hex(nd.status) & ", " & GetNtErrorString(nd.status) & ")"
                            End If
                        End If
                        CloseHandle hThread
                        If sName = "" Then
                            If sType = "Token" Then
                                Dim bUser() As Byte
                                Dim dwSize As Long
                                Dim lRet As Long = GetTokenInformation(hTarget, TokenUser, ByVal 0, 0, dwSize)
                                If Err.LastDllError = ERROR_INSUFFICIENT_BUFFER Then
                                    ReDim bUser(dwSize - 1)
                                      lRet = GetTokenInformation(hTarget, TokenUser, bUser(0), dwSize, dwSize)
                                End If
                                If lRet Then
                                    Dim sBufN As String = String$(MAX_SID_SIZE, 0)
                                    Dim sBufD As String = String$(MAX_SID_SIZE, 0)
                                    Dim use As SID_NAME_USE
                                    LookupAccountSid(vbNullString, CType(Of TOKEN_USER)(VarPtr(bUser(0))).User.Sid, sBufN, MAX_SID_SIZE, sBufD, MAX_SID_SIZE, use)
                                    sName = TrimNullW(sBufD) & "\" & TrimNullW(sBufN)
                                Else
                                    Debug.Print "GetTokenInformation Error; 0x" & Hex$(Err.LastDllError) & ", " & GetSystemErrorString(Err.LastDllError)
                                End If
                            End If
                        End If
                        If sName <> "" Then
                            curHandles(nCurH).sType = sType
                            If sType = "File" Then
                                curHandles(nCurH).sName = ConvertNtPathToDosPath(sName)
                            Else
                                curHandles(nCurH).sName = sName
                            End If
                            curHandles(nCurH).dwAccess = .Handles(i).GrantedAccess
                            curHandles(nCurH).HandleId = .Handles(i).HandleValue
                            AddDisplayHandle nCurH
                            nCurH += 1
                        End If
                    End If
                    CloseHandle hTarget
                    hTarget = 0
                    
                Next
                    ' DisplayHandle(sType, sName) 
            End If
        End With
        CloseHandle hProc
        Debug.Print "Finished listing handles for " & pid
        If nCurH Then
            nHSortKey = 1
            nHSortDir = 0
            Dim lpfn As LongPtr = AddressOf LVHSortProc
            Call SendMessage(hLVH, LVM_SORTITEMS, nHSortDir, ByVal lpfn)
        End If
    End Function
    Public Function NameQueryThreadProc(ByVal lpParameter As LongPtr) As Long
        With CType(Of NAME_QUERY_DATA)(lpParameter)
        .status = NtQueryObject(.hTarget, ObjectNameInformation, ByVal .pBuffer, .cbBuffer, ByVal 0)
        NameQueryThreadProc = 0
        End With
    End Function
 
    [ArrayBoundsChecks(False)]
    Private Function FindProcsUsingFile(ByVal sFile As String) As Long
        pidCur = -1
        Dim hFile As LongPtr
        Dim oa As OBJECT_ATTRIBUTES
        Dim iosb As IO_STATUS_BLOCK
        Dim status As NTSTATUS
        Dim fileName As UNICODE_STRING
        sFile = "\??\" & sFile
        RtlInitUnicodeString fileName, StrPtr(sFile)
        
        InitializeObjectAttributes(oa, _
                                VarPtr(fileName), _
                                OBJ_CASE_INSENSITIVE, _
                                0, _
                                0)
        
        status = NtOpenFile(hFile, _
                            FILE_READ_ATTRIBUTES Or SYNCHRONIZE, _
                            oa, _
                            iosb, _
                            FILE_SHARE_READ Or FILE_SHARE_WRITE Or FILE_SHARE_DELETE, _
                            FILE_NON_DIRECTORY_FILE Or FILE_SYNCHRONOUS_IO_NONALERT)
        
        If NT_SUCCESS(status) Then
            Dim cbBuf As Long = 1024
            Dim buf() As Byte
            ZeroMemory iosb, LenB(iosb)
            ReDim buf(cbBuf - 1)
            Do
                status = NtQueryInformationFile(hFile, iosb, buf(0), cbBuf, FileProcessIdsUsingFileInformation)
                If (status = STATUS_BUFFER_OVERFLOW) Or _
                    (status = STATUS_BUFFER_TOO_SMALL) Or _
                    (status = STATUS_INFO_LENGTH_MISMATCH) Then
                    cbBuf *= 2
                    ReDim buf(cbBuf - 1)
                Else
                    Exit Do
                End If
            Loop
            
            NtClose(hFile)
            
            If NT_SUCCESS(status) Then
                With CType(Of FILE_PROCESS_IDS_USING_FILE_INFORMATION)(VarPtr(buf(0)))
                    If .NumberOfProcessIdsInList Then
                    Text1.Text = "Processes using " & sFile & vbCrLf
                    Text1.Text &= "==========================" & vbCrLf
                    For j As Long = 0 To .NumberOfProcessIdsInList - 1
                        AppendUsingFile sFile, CLng(.ProcessIdList(j))
                    Next
                Else
                    Text1.Text = "No processes identified using " & sFile
                End If
                End With
                Return STATUS_SUCCESS
            End If
        End If
End Function
Private Sub AppendUsingFile(sFile As String, ByVal pid As Long)
    Dim idx As Long
    For i As Long = 0 To UBound(PLProcesses)
        If PLProcesses(i).pid = pid Then
            If PLProcesses(i).sCommandLine <> "" Then
                Text1.Text &= PLProcesses(i).sDisplayName & " (" & pid & "), CommandLine=" & PLProcesses(i).sCommandLine & vbCrLf
            Else
                Text1.Text &= PLProcesses(i).sDisplayName & " (" & pid & "), ProcessPath=" & PLProcesses(i).sFullPath & vbCrLf
            End If
        End If
    Next
End Sub

Private Function ShowHandleMenu(ByVal lp As LongPtr) As Long
    Dim hMenu As LongPtr
    Dim mii As MENUITEMINFOW
    Dim PT As POINT
    Dim idCmd As Long
     
    hMenu = CreatePopupMenu()
    
    With mii
        .cbSize = LenB(mii)
        .fMask = MIIM_ID Or MIIM_STRING 'Or MIIM_STATE
        .wID = 201
        .dwTypeData = StrPtr(sMnu1)
        .cch = Len(sMnu1)
        ' .fState = IIf(bPvLockCX, MFS_CHECKED, MFS_UNCHECKED)
        Call InsertMenuItemW(hMenu, 0, True, mii)
    End With
    With mii
        .cbSize = LenB(mii)
        .fMask = MIIM_ID Or MIIM_STRING 'Or MIIM_STATE
        .wID = 202
        .dwTypeData = StrPtr(sMnu2)
        .cch = Len(sMnu2)
        ' .fState = IIf(bPvLockCX, MFS_CHECKED, MFS_UNCHECKED)
        Call InsertMenuItemW(hMenu, 1, True, mii)
    End With
    
    
    Call GetCursorPos(PT)
    
    idCmd = TrackPopupMenu(hMenu, TPM_LEFTBUTTON Or TPM_RIGHTBUTTON Or TPM_LEFTALIGN Or TPM_TOPALIGN Or TPM_HORIZONTAL Or TPM_RETURNCMD, PT.x, PT.y, 0, hLVH, 0)
    If idCmd Then
        Select Case idCmd
            Case 201
                Dim hr As Long = CloseRemoteHandle(pidCur, curHandles(lp).HandleId)
                If hr = S_OK Then
                    ListView_DeleteItem(hLVH, CLng(ListView_GetSelectedItem(hLVH)))
                Else
                    Text1.Text = "Couldn't close handle, 0x" & Hex$(hr) & ": " & GetSystemErrorString(hr)
                    Beep
                End If
            Case 202
                Clipboard.SetText curHandles(lp).sName
        End Select
    End If
    Call DestroyMenu(hMenu)
End Function
Private Function ShowProcessMenu(ByVal lp As LongPtr) As Long
    Dim hMenu As LongPtr
    Dim mii As MENUITEMINFOW
    Dim PT As POINT
    Dim idCmd As Long
     
    hMenu = CreatePopupMenu()
    
    With mii
        .cbSize = LenB(mii)
        .fMask = MIIM_ID Or MIIM_STRING
        .wID = 301
        .dwTypeData = StrPtr(sPMnu1)
        .cch = Len(sPMnu1)
        Call InsertMenuItemW(hMenu, 0, True, mii)
    End With
    
    
    Call GetCursorPos(PT)
    
    idCmd = TrackPopupMenu(hMenu, TPM_LEFTBUTTON Or TPM_RIGHTBUTTON Or TPM_LEFTALIGN Or TPM_TOPALIGN Or TPM_HORIZONTAL Or TPM_RETURNCMD, PT.x, PT.y, 0, hLVH, 0)
    If idCmd Then
        Select Case idCmd
            Case 301
                Dim status As NTSTATUS = KillProcess(PLProcesses(lp).pid)
                If NT_SUCCESS(status) Then
                    ListView_DeleteItem(hLV, CLng(ListView_GetSelectedItem(hLV)))
                Else
                    Text1.Text = "Couldn't terminate process, 0x" & Hex$(status) & ": " & GetNtErrorString(status)
                    Beep
                End If
        End Select
    End If
    Call DestroyMenu(hMenu)
End Function


Private Function Subclass2(hWnd As LongPtr, lpFN As LongPtr, Optional uId As LongPtr = 0&, Optional dwRefData As LongPtr = 0&) As Boolean
If uId = 0 Then uId = hWnd
    Subclass2 = SetWindowSubclass(hWnd, lpFN, uId, dwRefData):      Debug.Assert Subclass2
End Function

Private Function UnSubclass2(hWnd As LongPtr, ByVal lpFN As LongPtr, pid As LongPtr) As Boolean
    UnSubclass2 = RemoveWindowSubclass(hWnd, lpFN, pid)
End Function
Private Function LVHSortProc(ByVal lParam1 As LongPtr, ByVal lParam2 As LongPtr, ByVal lParamSort As LongPtr) As Long
    
    Dim r As Long
    
    If nHSortKey = 1 Then 'Sort by type
        r = StrCmpLogicalW(StrPtr(curHandles(lParam1).sType), StrPtr(curHandles(lParam2).sType))
        ' If dbgsc < 10 Then
        '     Debug.Print "SortCmp " & PLProcesses(lParam1).sDisplayName & "|" & PLProcesses(lParam2).sDisplayName & "=" & r
        '     dbgsc += 1
        ' End If
    ElseIf nHSortKey = 2 Then 'Sort by pid
        r = StrCmpLogicalW(StrPtr(curHandles(lParam1).sName), StrPtr(curHandles(lParam2).sName))
        ' If dbgsc < 10 Then
        '     Debug.Print "SortPid " & PLProcesses(lParam1).pid & "|" & PLProcesses(lParam2).pid & "=" & r
        '     dbgsc += 1
        ' End If
    ElseIf nHSortKey = 3 Then 'Sort by access
        If curHandles(lParam1).dwAccess = curHandles(lParam2).dwAccess Then
            r = 0
        Else
            r = IIf(curHandles(lParam1).dwAccess > curHandles(lParam2).dwAccess, 1, -1)
        End If
    ElseIf nHSortKey = 4 Then 'Sort by access
        If curHandles(lParam1).dwAccess = curHandles(lParam2).dwAccess Then
            r = 0
        Else
            r = IIf(curHandles(lParam1).HandleId > curHandles(lParam2).HandleId, 1, -1)
        End If
    End If
    
    If lParamSort Then 'sortDescending, invert result
        Return r * -1
    Else
        Return r
    End If
End Function

Private Function LVHWndProc(ByVal lng_hWnd As LongPtr, ByVal uMsg As Long, ByVal wParam As LongPtr, ByVal lParam As LongPtr, ByVal uIdSubclass As LongPtr, ByVal dwRefData As LongPtr) As LongPtr
    
    Select Case uMsg
        
    Case WM_NOTIFY
        Dim NM As NMHDR
        Dim nmlv As NMLISTVIEW
        CopyMemory NM, ByVal lParam, LenB(NM)
        Select Case NM.Code
        Case LVN_COLUMNCLICK
                Dim nCol As Long
                CopyMemory nmlv, ByVal lParam, LenB(nmlv)
                nCol = CLng(GetHDItemlParam(hLVHHdr, nmlv.iSubItem))
                nHSortKey = nCol
                If nHSortDir = -1 Then
                    nHSortDir = 0
                ElseIf nHSortDir = 0 Then
                    nHSortDir = 1
                Else
                    nHSortDir = 0
                End If
                Debug.Print "LVH ColClick " & nCol, nHSortKey, nHSortDir
                Dim lpfn As LongPtr = AddressOf LVHSortProc
                Call SendMessage(hLVH, LVM_SORTITEMS, nHSortDir, ByVal lpfn)
                
        Case NM_RCLICK
            Dim lp As LongPtr
            Dim li As Long = CType(Of NMITEMACTIVATE)(lParam).iItem
            If li >= 0 Then
                Text1.Text = ""
                lp = GetLVItemlParam(hLVH, li)
                ShowHandleMenu(lp)
            End If
        End Select
        
        
        Case WM_DESTROY
            Call UnSubclass2(lng_hWnd, AddressOf LVHWndProc, uIdSubclass)
    End Select

LVHWndProc = DefSubclassProc(lng_hWnd, uMsg, wParam, lParam)

End Function


Private Function LVSortProc(ByVal lParam1 As LongPtr, ByVal lParam2 As LongPtr, ByVal lParamSort As LongPtr) As Long
    
    Dim r As Long
    
    If nSortKey = 0 Then 'Sort by name
        r = StrCmpLogicalW(StrPtr(PLProcesses(lParam1).sDisplayName), StrPtr(PLProcesses(lParam2).sDisplayName))
        ' If dbgsc < 10 Then
        '     Debug.Print "SortCmp " & PLProcesses(lParam1).sDisplayName & "|" & PLProcesses(lParam2).sDisplayName & "=" & r
        '     dbgsc += 1
        ' End If
    ElseIf nSortKey = 1 Then 'Sort by pid
        If PLProcesses(lParam1).pid = PLProcesses(lParam2).pid Then
            r = 0
        Else
            r = IIf(PLProcesses(lParam1).pid > PLProcesses(lParam2).pid, 1, -1)
        End If
        ' If dbgsc < 10 Then
        '     Debug.Print "SortPid " & PLProcesses(lParam1).pid & "|" & PLProcesses(lParam2).pid & "=" & r
        '     dbgsc += 1
        ' End If
    End If
    
    If lParamSort Then 'sortDescending, invert result
        Return r * -1
    Else
        Return r
    End If
End Function

Private Function LVWndProc(ByVal lng_hWnd As LongPtr, ByVal uMsg As Long, ByVal wParam As LongPtr, ByVal lParam As LongPtr, ByVal uIdSubclass As LongPtr, ByVal dwRefData As LongPtr) As LongPtr
    
    Select Case uMsg
        
    Case WM_NOTIFY
        Dim NM As NMHDR
        Dim nmlv As NMLISTVIEW
        CopyMemory NM, ByVal lParam, LenB(NM)
        Select Case NM.Code
        Case LVN_COLUMNCLICK
                Dim nCol As Long
                CopyMemory nmlv, ByVal lParam, LenB(nmlv)
                ' Debug.Print nmlv.iItem, nmlv.iSubItem
                nCol = CLng(GetHDItemlParam(hLVCHdr, nmlv.iSubItem))
                Debug.Print "nCol=" & nCol, GetHDItemlParam(hLVCHdr, 1)
                If nCol = 1 Then
                    nSortKey = 0
                Else
                    nSortKey = 1
                End If
                If nSortDir = -1 Then
                    nSortDir = 0
                ElseIf nSortDir = 0 Then
                    nSortDir = 1
                Else
                    nSortDir = 0
                End If
                Debug.Print "LVC ColClick " & nCol, nSortKey, nSortDir
                Dim lpfn As LongPtr = AddressOf LVSortProc
                Call SendMessage(hLV, LVM_SORTITEMS, nSortDir, ByVal lpfn)
                
        Case NM_DBLCLK
            Dim lp As LongPtr
            Dim li As Long = CType(Of NMITEMACTIVATE)(lParam).iItem
            If li >= 0 Then
                Text1.Text = ""
                lp = GetLVItemlParam(hLV, li)
                ListHandlesForProc(PLProcesses(CLng(lp)).pid)
            End If
            
        Case NM_RCLICK
            Dim lp2 As LongPtr
            Dim li2 As Long = CType(Of NMITEMACTIVATE)(lParam).iItem
            If li2 >= 0 Then
                Text1.Text = ""
                lp2 = GetLVItemlParam(hLV, li2)
                ShowProcessMenu(lp2)
            End If
        End Select
        
        
        Case WM_DESTROY
            Call UnSubclass2(lng_hWnd, AddressOf LVWndProc, uIdSubclass)
    End Select

LVWndProc = DefSubclassProc(lng_hWnd, uMsg, wParam, lParam)

End Function

    


End Class